{"ast":null,"code":"// Interactions.js\nimport { ethers } from 'ethers';\nimport { setProvider, setNetwork, setAccount } from './reducers/provider';\nimport { setContracts, setSymbols, balancesLoaded } from './reducers/tokens';\nimport { setContract, selectAmm, sharesLoaded, swapsLoaded, depositRequest, depositSuccess, depositFail, withdrawRequest, withdrawSuccess, withdrawFail, swapRequest, swapSuccess, swapFail } from './reducers/amm';\nimport { setAggregatorContract, updateAmmData } from './reducers/aggregator';\nimport TOKEN_ABI from '../abis/Token.json';\nimport AMM_ABI from '../abis/AMM.json';\nimport AGGREGATOR_ABI from '../abis/Aggregator.json';\nimport config from '../config.json';\nexport const loadProvider = dispatch => {\n  const provider = new ethers.providers.Web3Provider(window.ethereum);\n  dispatch(setProvider(provider));\n  return provider;\n};\nexport const loadNetwork = async (provider, dispatch) => {\n  const {\n    chainId\n  } = await provider.getNetwork();\n  dispatch(setNetwork(chainId));\n  return chainId;\n};\nexport const loadAccount = async dispatch => {\n  const accounts = await window.ethereum.request({\n    method: 'eth_requestAccounts'\n  });\n  const account = ethers.utils.getAddress(accounts[0]);\n  dispatch(setAccount(account));\n  return account;\n};\n\n// Load Contracts\nexport const loadTokens = async (provider, chainId, dispatch) => {\n  const dapp = new ethers.Contract(config[chainId].dapp.address, TOKEN_ABI, provider);\n  const usd = new ethers.Contract(config[chainId].usd.address, TOKEN_ABI, provider);\n  dispatch(setContracts([dapp, usd]));\n  dispatch(setSymbols([await dapp.symbol(), await usd.symbol()]));\n};\nexport const loadAMM = async (provider, chainId, ammNumber, dispatch) => {\n  var _config$chainId$ammNu;\n  // Ensure ammNumber is either 'amm1' or 'amm2'\n  if (!['amm1', 'amm2'].includes(ammNumber)) {\n    console.error(`Invalid AMM number: ${ammNumber}`);\n    return;\n  }\n  const ammAddress = (_config$chainId$ammNu = config[chainId][ammNumber]) === null || _config$chainId$ammNu === void 0 ? void 0 : _config$chainId$ammNu.address;\n  if (!ammAddress) {\n    console.error(`AMM address not found for ${ammNumber} on chain ${chainId}`);\n    return;\n  }\n  const ammContract = new ethers.Contract(ammAddress, AMM_ABI, provider);\n  dispatch(setContract({\n    ammNumber,\n    contract: ammContract\n  }));\n};\nexport const loadAggregator = async (provider, chainId, dispatch) => {\n  const aggregatorAddress = config[chainId].aggregator.address;\n  const aggregator = new ethers.Contract(aggregatorAddress, AGGREGATOR_ABI, provider);\n  dispatch(setAggregatorContract(aggregator));\n};\n\n// Load Balances & Shares\nexport const loadBalances = async (amm, tokens, account, dispatch) => {\n  const balance1 = await tokens[0].balanceOf(account);\n  const balance2 = await tokens[1].balanceOf(account);\n  dispatch(balancesLoaded([ethers.utils.formatUnits(balance1.toString(), 'ether'), ethers.utils.formatUnits(balance2.toString(), 'ether')]));\n  const shares = await amm.shares(account);\n  dispatch(sharesLoaded(ethers.utils.formatUnits(shares.toString(), 'ether')));\n};\n\n// Add Liquidity\nexport const addLiquidity = async (provider, amm, tokens, amounts, dispatch) => {\n  try {\n    dispatch(depositRequest());\n    const signer = provider.getSigner();\n    await tokens[0].connect(signer).approve(amm.address, amounts[0]);\n    await tokens[1].connect(signer).approve(amm.address, amounts[1]);\n    const transaction = await amm.connect(signer).addLiquidity(amounts[0], amounts[1]);\n    await transaction.wait();\n    dispatch(depositSuccess(transaction.hash));\n  } catch (error) {\n    console.error('Add liquidity failed:', error);\n    dispatch(depositFail());\n  }\n};\n\n// Remove Liquidity\nexport const removeLiquidity = async (provider, amm, shares, dispatch) => {\n  try {\n    dispatch(withdrawRequest());\n    const signer = provider.getSigner();\n    const transaction = await amm.connect(signer).removeLiquidity(shares);\n    await transaction.wait();\n    dispatch(withdrawSuccess(transaction.hash));\n  } catch (error) {\n    console.error('Withdraw failed:', error);\n    dispatch(withdrawFail());\n  }\n};\n\n// Swap\nexport const swap = async (provider, amm, token, symbol, amount, dispatch) => {\n  try {\n    dispatch(swapRequest());\n    const signer = provider.getSigner();\n\n    // Approve the AMM contract to spend the token\n    await token.connect(signer).approve(amm.address, amount);\n    let transaction;\n    if (symbol === \"DAPP\") {\n      transaction = await amm.connect(signer).swapToken1(amount);\n    } else {\n      transaction = await amm.connect(signer).swapToken2(amount);\n    }\n    await transaction.wait();\n    dispatch(swapSuccess(transaction.hash));\n  } catch (error) {\n    console.error('Swap failed:', error);\n    dispatch(swapFail());\n  }\n};\n\n// Load All Swaps\nexport const loadAllSwaps = async (provider, amm, dispatch) => {\n  const block = await provider.getBlockNumber();\n  const swapStream = await amm.queryFilter('Swap', 0, block);\n  const swaps = swapStream.map(event => ({\n    hash: event.transactionHash,\n    args: event.args\n  }));\n  dispatch(swapsLoaded(swaps));\n};\n\n// Load Balances from both AMMs for Aggregator\nexport const loadAggregatorBalances = async (amm1, amm2, tokens, provider) => {\n  try {\n    // Connect to AMM contracts with the provider\n    const amm1Contract = new ethers.Contract(amm1.address, AMM_ABI, provider);\n    const amm2Contract = new ethers.Contract(amm2.address, AMM_ABI, provider);\n\n    // Fetch balances from both AMMs\n    const balancesAmm1 = await Promise.all([amm1Contract.token1Balance(), amm1Contract.token2Balance()]);\n    const balancesAmm2 = await Promise.all([amm2Contract.token1Balance(), amm2Contract.token2Balance()]);\n\n    // Format balances\n    const formattedBalancesAmm1 = balancesAmm1.map(balance => ethers.utils.formatUnits(balance.toString(), 'ether'));\n    const formattedBalancesAmm2 = balancesAmm2.map(balance => ethers.utils.formatUnits(balance.toString(), 'ether'));\n    return {\n      amm1: {\n        token1Balance: formattedBalancesAmm1[0],\n        token2Balance: formattedBalancesAmm1[1]\n      },\n      amm2: {\n        token1Balance: formattedBalancesAmm2[0],\n        token2Balance: formattedBalancesAmm2[1]\n      }\n    };\n  } catch (error) {\n    console.error('Error loading aggregator balances:', error);\n    return {\n      amm1: {\n        token1Balance: '0',\n        token2Balance: '0'\n      },\n      amm2: {\n        token1Balance: '0',\n        token2Balance: '0'\n      }\n    };\n  }\n};\n\n// Update selected AMM in redux\nexport const updateSelectedAmm = (selectedAmmAddress, dispatch) => {\n  dispatch(selectAmm(selectedAmmAddress));\n};\nexport const loadAmmData = async (provider, amm1Address, amm2Address, dispatch) => {\n  try {\n    const amm1Contract = new ethers.Contract(amm1Address, AMM_ABI, provider);\n    const amm2Contract = new ethers.Contract(amm2Address, AMM_ABI, provider);\n\n    // Fetch balances and calculate rates for AMM1\n    const [token1BalanceAmm1, token2BalanceAmm1] = await Promise.all([amm1Contract.token1Balance(), amm1Contract.token2Balance()]);\n    const rate1to2Amm1 = token2BalanceAmm1 / token1BalanceAmm1;\n    const rate2to1Amm1 = token1BalanceAmm1 / token2BalanceAmm1;\n\n    // Fetch balances and calculate rates for AMM2\n    const [token1BalanceAmm2, token2BalanceAmm2] = await Promise.all([amm2Contract.token1Balance(), amm2Contract.token2Balance()]);\n    const rate1to2Amm2 = token2BalanceAmm2 / token1BalanceAmm2;\n    const rate2to1Amm2 = token1BalanceAmm2 / token2BalanceAmm2;\n\n    // Dispatch actions to update aggregator reducer\n    dispatch(updateAmmData({\n      ammNumber: 'amm1',\n      data: {\n        token1Balance: ethers.utils.formatUnits(token1BalanceAmm1.toString(), 'ether'),\n        token2Balance: ethers.utils.formatUnits(token2BalanceAmm1.toString(), 'ether'),\n        rate1to2: rate1to2Amm1,\n        rate2to1: rate2to1Amm1\n      }\n    }));\n    dispatch(updateAmmData({\n      ammNumber: 'amm2',\n      data: {\n        token1Balance: ethers.utils.formatUnits(token1BalanceAmm2.toString(), 'ether'),\n        token2Balance: ethers.utils.formatUnits(token2BalanceAmm2.toString(), 'ether'),\n        rate1to2: rate1to2Amm2,\n        rate2to1: rate2to1Amm2\n      }\n    }));\n  } catch (error) {\n    console.error('Error loading balances and rates from AMMs:', error);\n  }\n};\nexport const aggregatorSwap = async (provider, selectedBestAmm, ammContracts, tokenContract, tokenSymbol, amount, dispatch) => {\n  try {\n    dispatch(swapRequest());\n    const signer = provider.getSigner();\n    const ammContract = selectedBestAmm === 'amm1' ? ammContracts.amm1 : ammContracts.amm2;\n\n    // Approve the AMM contract to spend the token\n    await tokenContract.connect(signer).approve(ammContract.address, amount);\n    let transaction;\n    if (tokenSymbol === \"DAPP\") {\n      transaction = await ammContract.connect(signer).swapToken1(amount);\n    } else {\n      transaction = await ammContract.connect(signer).swapToken2(amount);\n    }\n    await transaction.wait();\n    dispatch(swapSuccess(transaction.hash));\n  } catch (error) {\n    console.error('Aggregator swap failed:', error);\n    dispatch(swapFail());\n  }\n};","map":{"version":3,"names":["ethers","setProvider","setNetwork","setAccount","setContracts","setSymbols","balancesLoaded","setContract","selectAmm","sharesLoaded","swapsLoaded","depositRequest","depositSuccess","depositFail","withdrawRequest","withdrawSuccess","withdrawFail","swapRequest","swapSuccess","swapFail","setAggregatorContract","updateAmmData","TOKEN_ABI","AMM_ABI","AGGREGATOR_ABI","config","loadProvider","dispatch","provider","providers","Web3Provider","window","ethereum","loadNetwork","chainId","getNetwork","loadAccount","accounts","request","method","account","utils","getAddress","loadTokens","dapp","Contract","address","usd","symbol","loadAMM","ammNumber","_config$chainId$ammNu","includes","console","error","ammAddress","ammContract","contract","loadAggregator","aggregatorAddress","aggregator","loadBalances","amm","tokens","balance1","balanceOf","balance2","formatUnits","toString","shares","addLiquidity","amounts","signer","getSigner","connect","approve","transaction","wait","hash","removeLiquidity","swap","token","amount","swapToken1","swapToken2","loadAllSwaps","block","getBlockNumber","swapStream","queryFilter","swaps","map","event","transactionHash","args","loadAggregatorBalances","amm1","amm2","amm1Contract","amm2Contract","balancesAmm1","Promise","all","token1Balance","token2Balance","balancesAmm2","formattedBalancesAmm1","balance","formattedBalancesAmm2","updateSelectedAmm","selectedAmmAddress","loadAmmData","amm1Address","amm2Address","token1BalanceAmm1","token2BalanceAmm1","rate1to2Amm1","rate2to1Amm1","token1BalanceAmm2","token2BalanceAmm2","rate1to2Amm2","rate2to1Amm2","data","rate1to2","rate2to1","aggregatorSwap","selectedBestAmm","ammContracts","tokenContract","tokenSymbol"],"sources":["/Users/nicholasmakdessi/Desktop/Blockchain/Mentorship/capstone/aggregator/src/store/interactions.js"],"sourcesContent":["// Interactions.js\nimport { ethers } from 'ethers';\n\nimport {\n  setProvider,\n  setNetwork,\n  setAccount\n} from './reducers/provider';\n\nimport {\n  setContracts,\n  setSymbols,\n  balancesLoaded\n} from './reducers/tokens';\n\nimport {\n  setContract,\n  selectAmm,\n  sharesLoaded,\n  swapsLoaded,\n  depositRequest,\n  depositSuccess,\n  depositFail,\n  withdrawRequest,\n  withdrawSuccess,\n  withdrawFail,\n  swapRequest,\n  swapSuccess,\n  swapFail\n} from './reducers/amm';\n\nimport {\n  setAggregatorContract,\n  updateAmmData,\n} from './reducers/aggregator';\n\nimport TOKEN_ABI from '../abis/Token.json';\nimport AMM_ABI from '../abis/AMM.json';\nimport AGGREGATOR_ABI from '../abis/Aggregator.json'; \nimport config from '../config.json';\n\nexport const loadProvider = (dispatch) => {\n  const provider = new ethers.providers.Web3Provider(window.ethereum);\n  dispatch(setProvider(provider));\n\n  return provider;\n};\n\nexport const loadNetwork = async (provider, dispatch) => {\n  const { chainId } = await provider.getNetwork();\n  dispatch(setNetwork(chainId));\n\n  return chainId;\n};\n\nexport const loadAccount = async (dispatch) => {\n  const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });\n  const account = ethers.utils.getAddress(accounts[0]);\n  dispatch(setAccount(account));\n\n  return account;\n};\n\n// Load Contracts\nexport const loadTokens = async (provider, chainId, dispatch) => {\n  const dapp = new ethers.Contract(config[chainId].dapp.address, TOKEN_ABI, provider);\n  const usd = new ethers.Contract(config[chainId].usd.address, TOKEN_ABI, provider);\n\n  dispatch(setContracts([dapp, usd]));\n  dispatch(setSymbols([await dapp.symbol(), await usd.symbol()]));\n};\n\nexport const loadAMM = async (provider, chainId, ammNumber, dispatch) => {\n  // Ensure ammNumber is either 'amm1' or 'amm2'\n  if (!['amm1', 'amm2'].includes(ammNumber)) {\n    console.error(`Invalid AMM number: ${ammNumber}`);\n    return;\n  }\n\n  const ammAddress = config[chainId][ammNumber]?.address;\n  if (!ammAddress) {\n    console.error(`AMM address not found for ${ammNumber} on chain ${chainId}`);\n    return;\n  }\n\n  const ammContract = new ethers.Contract(ammAddress, AMM_ABI, provider);\n  dispatch(setContract({ ammNumber, contract: ammContract }));\n};\n\n\n\nexport const loadAggregator = async (provider, chainId, dispatch) => {\n  const aggregatorAddress = config[chainId].aggregator.address;\n  const aggregator = new ethers.Contract(aggregatorAddress, AGGREGATOR_ABI, provider);\n\n  dispatch(setAggregatorContract(aggregator));\n};\n\n\n// Load Balances & Shares\nexport const loadBalances = async (amm, tokens, account, dispatch) => {\n  const balance1 = await tokens[0].balanceOf(account);\n  const balance2 = await tokens[1].balanceOf(account);\n\n  dispatch(balancesLoaded([\n    ethers.utils.formatUnits(balance1.toString(), 'ether'),\n    ethers.utils.formatUnits(balance2.toString(), 'ether')\n  ]));\n\n  const shares = await amm.shares(account);\n  dispatch(sharesLoaded(ethers.utils.formatUnits(shares.toString(), 'ether')));\n};\n\n// Add Liquidity\nexport const addLiquidity = async (provider, amm, tokens, amounts, dispatch) => {\n  try {\n    dispatch(depositRequest());\n\n    const signer = provider.getSigner();\n\n    await tokens[0].connect(signer).approve(amm.address, amounts[0]);\n    await tokens[1].connect(signer).approve(amm.address, amounts[1]);\n\n    const transaction = await amm.connect(signer).addLiquidity(amounts[0], amounts[1]);\n    await transaction.wait();\n\n    dispatch(depositSuccess(transaction.hash));\n  } catch (error) {\n    console.error('Add liquidity failed:', error);\n    dispatch(depositFail());\n  }\n};\n\n// Remove Liquidity\nexport const removeLiquidity = async (provider, amm, shares, dispatch) => {\n  try {\n    dispatch(withdrawRequest());\n\n    const signer = provider.getSigner();\n    const transaction = await amm.connect(signer).removeLiquidity(shares);\n    await transaction.wait();\n\n    dispatch(withdrawSuccess(transaction.hash));\n  } catch (error) {\n    console.error('Withdraw failed:', error);\n    dispatch(withdrawFail());\n  }\n};\n\n\n// Swap\nexport const swap = async (provider, amm, token, symbol, amount, dispatch) => {\n  try {\n    dispatch(swapRequest());\n\n    const signer = provider.getSigner();\n\n    // Approve the AMM contract to spend the token\n    await token.connect(signer).approve(amm.address, amount);\n\n    let transaction;\n    if (symbol === \"DAPP\") {\n      transaction = await amm.connect(signer).swapToken1(amount);\n    } else {\n      transaction = await amm.connect(signer).swapToken2(amount);\n    }\n\n    await transaction.wait();\n\n    dispatch(swapSuccess(transaction.hash));\n\n  } catch (error) {\n    console.error('Swap failed:', error);\n    dispatch(swapFail());\n  }\n};\n\n\n// Load All Swaps\nexport const loadAllSwaps = async (provider, amm, dispatch) => {\n  const block = await provider.getBlockNumber();\n\n  const swapStream = await amm.queryFilter('Swap', 0, block);\n  const swaps = swapStream.map(event => ({\n    hash: event.transactionHash,\n    args: event.args\n  }));\n\n  dispatch(swapsLoaded(swaps));\n};\n\n\n\n\n// Load Balances from both AMMs for Aggregator\nexport const loadAggregatorBalances = async (amm1, amm2, tokens, provider) => {\n  try {\n    // Connect to AMM contracts with the provider\n    const amm1Contract = new ethers.Contract(amm1.address, AMM_ABI, provider);\n    const amm2Contract = new ethers.Contract(amm2.address, AMM_ABI, provider);\n\n    // Fetch balances from both AMMs\n    const balancesAmm1 = await Promise.all([\n      amm1Contract.token1Balance(),\n      amm1Contract.token2Balance()\n    ]);\n\n    const balancesAmm2 = await Promise.all([\n      amm2Contract.token1Balance(),\n      amm2Contract.token2Balance()\n    ]);\n\n    // Format balances\n    const formattedBalancesAmm1 = balancesAmm1.map(balance => ethers.utils.formatUnits(balance.toString(), 'ether'));\n    const formattedBalancesAmm2 = balancesAmm2.map(balance => ethers.utils.formatUnits(balance.toString(), 'ether'));\n\n    return {\n      amm1: {\n        token1Balance: formattedBalancesAmm1[0],\n        token2Balance: formattedBalancesAmm1[1]\n      },\n      amm2: {\n        token1Balance: formattedBalancesAmm2[0],\n        token2Balance: formattedBalancesAmm2[1]\n      }\n    };\n  } catch (error) {\n    console.error('Error loading aggregator balances:', error);\n    return { amm1: { token1Balance: '0', token2Balance: '0' }, amm2: { token1Balance: '0', token2Balance: '0' } };\n  }\n};\n\n\n\n// Update selected AMM in redux\nexport const updateSelectedAmm = (selectedAmmAddress, dispatch) => {\n  dispatch(selectAmm(selectedAmmAddress));\n};\n\n\n\n\nexport const loadAmmData = async (provider, amm1Address, amm2Address, dispatch) => {\n  try {\n    const amm1Contract = new ethers.Contract(amm1Address, AMM_ABI, provider);\n    const amm2Contract = new ethers.Contract(amm2Address, AMM_ABI, provider);\n\n    // Fetch balances and calculate rates for AMM1\n    const [token1BalanceAmm1, token2BalanceAmm1] = await Promise.all([\n      amm1Contract.token1Balance(),\n      amm1Contract.token2Balance(),\n    ]);\n    const rate1to2Amm1 = token2BalanceAmm1 / token1BalanceAmm1;\n    const rate2to1Amm1 = token1BalanceAmm1 / token2BalanceAmm1;\n\n    // Fetch balances and calculate rates for AMM2\n    const [token1BalanceAmm2, token2BalanceAmm2] = await Promise.all([\n      amm2Contract.token1Balance(),\n      amm2Contract.token2Balance(),\n    ]);\n    const rate1to2Amm2 = token2BalanceAmm2 / token1BalanceAmm2;\n    const rate2to1Amm2 = token1BalanceAmm2 / token2BalanceAmm2;\n\n    // Dispatch actions to update aggregator reducer\n    dispatch(updateAmmData({\n      ammNumber: 'amm1',\n      data: {\n        token1Balance: ethers.utils.formatUnits(token1BalanceAmm1.toString(), 'ether'),\n        token2Balance: ethers.utils.formatUnits(token2BalanceAmm1.toString(), 'ether'),\n        rate1to2: rate1to2Amm1,\n        rate2to1: rate2to1Amm1\n      }\n    }));\n    dispatch(updateAmmData({\n      ammNumber: 'amm2',\n      data: {\n        token1Balance: ethers.utils.formatUnits(token1BalanceAmm2.toString(), 'ether'),\n        token2Balance: ethers.utils.formatUnits(token2BalanceAmm2.toString(), 'ether'),\n        rate1to2: rate1to2Amm2,\n        rate2to1: rate2to1Amm2\n      }\n    }));\n  } catch (error) {\n    console.error('Error loading balances and rates from AMMs:', error);\n  }\n};\n\nexport const aggregatorSwap = async (provider, selectedBestAmm, ammContracts, tokenContract, tokenSymbol, amount, dispatch) => {\n  try {\n    dispatch(swapRequest());\n\n    const signer = provider.getSigner();\n    const ammContract = selectedBestAmm === 'amm1' ? ammContracts.amm1 : ammContracts.amm2;\n\n    // Approve the AMM contract to spend the token\n    await tokenContract.connect(signer).approve(ammContract.address, amount);\n\n    let transaction;\n    if (tokenSymbol === \"DAPP\") {\n      transaction = await ammContract.connect(signer).swapToken1(amount);\n    } else {\n      transaction = await ammContract.connect(signer).swapToken2(amount);\n    }\n\n    await transaction.wait();\n\n    dispatch(swapSuccess(transaction.hash));\n\n  } catch (error) {\n    console.error('Aggregator swap failed:', error);\n    dispatch(swapFail());\n  }\n};\n"],"mappings":"AAAA;AACA,SAASA,MAAM,QAAQ,QAAQ;AAE/B,SACEC,WAAW,EACXC,UAAU,EACVC,UAAU,QACL,qBAAqB;AAE5B,SACEC,YAAY,EACZC,UAAU,EACVC,cAAc,QACT,mBAAmB;AAE1B,SACEC,WAAW,EACXC,SAAS,EACTC,YAAY,EACZC,WAAW,EACXC,cAAc,EACdC,cAAc,EACdC,WAAW,EACXC,eAAe,EACfC,eAAe,EACfC,YAAY,EACZC,WAAW,EACXC,WAAW,EACXC,QAAQ,QACH,gBAAgB;AAEvB,SACEC,qBAAqB,EACrBC,aAAa,QACR,uBAAuB;AAE9B,OAAOC,SAAS,MAAM,oBAAoB;AAC1C,OAAOC,OAAO,MAAM,kBAAkB;AACtC,OAAOC,cAAc,MAAM,yBAAyB;AACpD,OAAOC,MAAM,MAAM,gBAAgB;AAEnC,OAAO,MAAMC,YAAY,GAAIC,QAAQ,IAAK;EACxC,MAAMC,QAAQ,GAAG,IAAI5B,MAAM,CAAC6B,SAAS,CAACC,YAAY,CAACC,MAAM,CAACC,QAAQ,CAAC;EACnEL,QAAQ,CAAC1B,WAAW,CAAC2B,QAAQ,CAAC,CAAC;EAE/B,OAAOA,QAAQ;AACjB,CAAC;AAED,OAAO,MAAMK,WAAW,GAAG,MAAAA,CAAOL,QAAQ,EAAED,QAAQ,KAAK;EACvD,MAAM;IAAEO;EAAQ,CAAC,GAAG,MAAMN,QAAQ,CAACO,UAAU,CAAC,CAAC;EAC/CR,QAAQ,CAACzB,UAAU,CAACgC,OAAO,CAAC,CAAC;EAE7B,OAAOA,OAAO;AAChB,CAAC;AAED,OAAO,MAAME,WAAW,GAAG,MAAOT,QAAQ,IAAK;EAC7C,MAAMU,QAAQ,GAAG,MAAMN,MAAM,CAACC,QAAQ,CAACM,OAAO,CAAC;IAAEC,MAAM,EAAE;EAAsB,CAAC,CAAC;EACjF,MAAMC,OAAO,GAAGxC,MAAM,CAACyC,KAAK,CAACC,UAAU,CAACL,QAAQ,CAAC,CAAC,CAAC,CAAC;EACpDV,QAAQ,CAACxB,UAAU,CAACqC,OAAO,CAAC,CAAC;EAE7B,OAAOA,OAAO;AAChB,CAAC;;AAED;AACA,OAAO,MAAMG,UAAU,GAAG,MAAAA,CAAOf,QAAQ,EAAEM,OAAO,EAAEP,QAAQ,KAAK;EAC/D,MAAMiB,IAAI,GAAG,IAAI5C,MAAM,CAAC6C,QAAQ,CAACpB,MAAM,CAACS,OAAO,CAAC,CAACU,IAAI,CAACE,OAAO,EAAExB,SAAS,EAAEM,QAAQ,CAAC;EACnF,MAAMmB,GAAG,GAAG,IAAI/C,MAAM,CAAC6C,QAAQ,CAACpB,MAAM,CAACS,OAAO,CAAC,CAACa,GAAG,CAACD,OAAO,EAAExB,SAAS,EAAEM,QAAQ,CAAC;EAEjFD,QAAQ,CAACvB,YAAY,CAAC,CAACwC,IAAI,EAAEG,GAAG,CAAC,CAAC,CAAC;EACnCpB,QAAQ,CAACtB,UAAU,CAAC,CAAC,MAAMuC,IAAI,CAACI,MAAM,CAAC,CAAC,EAAE,MAAMD,GAAG,CAACC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;AACjE,CAAC;AAED,OAAO,MAAMC,OAAO,GAAG,MAAAA,CAAOrB,QAAQ,EAAEM,OAAO,EAAEgB,SAAS,EAAEvB,QAAQ,KAAK;EAAA,IAAAwB,qBAAA;EACvE;EACA,IAAI,CAAC,CAAC,MAAM,EAAE,MAAM,CAAC,CAACC,QAAQ,CAACF,SAAS,CAAC,EAAE;IACzCG,OAAO,CAACC,KAAK,CAAE,uBAAsBJ,SAAU,EAAC,CAAC;IACjD;EACF;EAEA,MAAMK,UAAU,IAAAJ,qBAAA,GAAG1B,MAAM,CAACS,OAAO,CAAC,CAACgB,SAAS,CAAC,cAAAC,qBAAA,uBAA1BA,qBAAA,CAA4BL,OAAO;EACtD,IAAI,CAACS,UAAU,EAAE;IACfF,OAAO,CAACC,KAAK,CAAE,6BAA4BJ,SAAU,aAAYhB,OAAQ,EAAC,CAAC;IAC3E;EACF;EAEA,MAAMsB,WAAW,GAAG,IAAIxD,MAAM,CAAC6C,QAAQ,CAACU,UAAU,EAAEhC,OAAO,EAAEK,QAAQ,CAAC;EACtED,QAAQ,CAACpB,WAAW,CAAC;IAAE2C,SAAS;IAAEO,QAAQ,EAAED;EAAY,CAAC,CAAC,CAAC;AAC7D,CAAC;AAID,OAAO,MAAME,cAAc,GAAG,MAAAA,CAAO9B,QAAQ,EAAEM,OAAO,EAAEP,QAAQ,KAAK;EACnE,MAAMgC,iBAAiB,GAAGlC,MAAM,CAACS,OAAO,CAAC,CAAC0B,UAAU,CAACd,OAAO;EAC5D,MAAMc,UAAU,GAAG,IAAI5D,MAAM,CAAC6C,QAAQ,CAACc,iBAAiB,EAAEnC,cAAc,EAAEI,QAAQ,CAAC;EAEnFD,QAAQ,CAACP,qBAAqB,CAACwC,UAAU,CAAC,CAAC;AAC7C,CAAC;;AAGD;AACA,OAAO,MAAMC,YAAY,GAAG,MAAAA,CAAOC,GAAG,EAAEC,MAAM,EAAEvB,OAAO,EAAEb,QAAQ,KAAK;EACpE,MAAMqC,QAAQ,GAAG,MAAMD,MAAM,CAAC,CAAC,CAAC,CAACE,SAAS,CAACzB,OAAO,CAAC;EACnD,MAAM0B,QAAQ,GAAG,MAAMH,MAAM,CAAC,CAAC,CAAC,CAACE,SAAS,CAACzB,OAAO,CAAC;EAEnDb,QAAQ,CAACrB,cAAc,CAAC,CACtBN,MAAM,CAACyC,KAAK,CAAC0B,WAAW,CAACH,QAAQ,CAACI,QAAQ,CAAC,CAAC,EAAE,OAAO,CAAC,EACtDpE,MAAM,CAACyC,KAAK,CAAC0B,WAAW,CAACD,QAAQ,CAACE,QAAQ,CAAC,CAAC,EAAE,OAAO,CAAC,CACvD,CAAC,CAAC;EAEH,MAAMC,MAAM,GAAG,MAAMP,GAAG,CAACO,MAAM,CAAC7B,OAAO,CAAC;EACxCb,QAAQ,CAAClB,YAAY,CAACT,MAAM,CAACyC,KAAK,CAAC0B,WAAW,CAACE,MAAM,CAACD,QAAQ,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC;AAC9E,CAAC;;AAED;AACA,OAAO,MAAME,YAAY,GAAG,MAAAA,CAAO1C,QAAQ,EAAEkC,GAAG,EAAEC,MAAM,EAAEQ,OAAO,EAAE5C,QAAQ,KAAK;EAC9E,IAAI;IACFA,QAAQ,CAAChB,cAAc,CAAC,CAAC,CAAC;IAE1B,MAAM6D,MAAM,GAAG5C,QAAQ,CAAC6C,SAAS,CAAC,CAAC;IAEnC,MAAMV,MAAM,CAAC,CAAC,CAAC,CAACW,OAAO,CAACF,MAAM,CAAC,CAACG,OAAO,CAACb,GAAG,CAAChB,OAAO,EAAEyB,OAAO,CAAC,CAAC,CAAC,CAAC;IAChE,MAAMR,MAAM,CAAC,CAAC,CAAC,CAACW,OAAO,CAACF,MAAM,CAAC,CAACG,OAAO,CAACb,GAAG,CAAChB,OAAO,EAAEyB,OAAO,CAAC,CAAC,CAAC,CAAC;IAEhE,MAAMK,WAAW,GAAG,MAAMd,GAAG,CAACY,OAAO,CAACF,MAAM,CAAC,CAACF,YAAY,CAACC,OAAO,CAAC,CAAC,CAAC,EAAEA,OAAO,CAAC,CAAC,CAAC,CAAC;IAClF,MAAMK,WAAW,CAACC,IAAI,CAAC,CAAC;IAExBlD,QAAQ,CAACf,cAAc,CAACgE,WAAW,CAACE,IAAI,CAAC,CAAC;EAC5C,CAAC,CAAC,OAAOxB,KAAK,EAAE;IACdD,OAAO,CAACC,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;IAC7C3B,QAAQ,CAACd,WAAW,CAAC,CAAC,CAAC;EACzB;AACF,CAAC;;AAED;AACA,OAAO,MAAMkE,eAAe,GAAG,MAAAA,CAAOnD,QAAQ,EAAEkC,GAAG,EAAEO,MAAM,EAAE1C,QAAQ,KAAK;EACxE,IAAI;IACFA,QAAQ,CAACb,eAAe,CAAC,CAAC,CAAC;IAE3B,MAAM0D,MAAM,GAAG5C,QAAQ,CAAC6C,SAAS,CAAC,CAAC;IACnC,MAAMG,WAAW,GAAG,MAAMd,GAAG,CAACY,OAAO,CAACF,MAAM,CAAC,CAACO,eAAe,CAACV,MAAM,CAAC;IACrE,MAAMO,WAAW,CAACC,IAAI,CAAC,CAAC;IAExBlD,QAAQ,CAACZ,eAAe,CAAC6D,WAAW,CAACE,IAAI,CAAC,CAAC;EAC7C,CAAC,CAAC,OAAOxB,KAAK,EAAE;IACdD,OAAO,CAACC,KAAK,CAAC,kBAAkB,EAAEA,KAAK,CAAC;IACxC3B,QAAQ,CAACX,YAAY,CAAC,CAAC,CAAC;EAC1B;AACF,CAAC;;AAGD;AACA,OAAO,MAAMgE,IAAI,GAAG,MAAAA,CAAOpD,QAAQ,EAAEkC,GAAG,EAAEmB,KAAK,EAAEjC,MAAM,EAAEkC,MAAM,EAAEvD,QAAQ,KAAK;EAC5E,IAAI;IACFA,QAAQ,CAACV,WAAW,CAAC,CAAC,CAAC;IAEvB,MAAMuD,MAAM,GAAG5C,QAAQ,CAAC6C,SAAS,CAAC,CAAC;;IAEnC;IACA,MAAMQ,KAAK,CAACP,OAAO,CAACF,MAAM,CAAC,CAACG,OAAO,CAACb,GAAG,CAAChB,OAAO,EAAEoC,MAAM,CAAC;IAExD,IAAIN,WAAW;IACf,IAAI5B,MAAM,KAAK,MAAM,EAAE;MACrB4B,WAAW,GAAG,MAAMd,GAAG,CAACY,OAAO,CAACF,MAAM,CAAC,CAACW,UAAU,CAACD,MAAM,CAAC;IAC5D,CAAC,MAAM;MACLN,WAAW,GAAG,MAAMd,GAAG,CAACY,OAAO,CAACF,MAAM,CAAC,CAACY,UAAU,CAACF,MAAM,CAAC;IAC5D;IAEA,MAAMN,WAAW,CAACC,IAAI,CAAC,CAAC;IAExBlD,QAAQ,CAACT,WAAW,CAAC0D,WAAW,CAACE,IAAI,CAAC,CAAC;EAEzC,CAAC,CAAC,OAAOxB,KAAK,EAAE;IACdD,OAAO,CAACC,KAAK,CAAC,cAAc,EAAEA,KAAK,CAAC;IACpC3B,QAAQ,CAACR,QAAQ,CAAC,CAAC,CAAC;EACtB;AACF,CAAC;;AAGD;AACA,OAAO,MAAMkE,YAAY,GAAG,MAAAA,CAAOzD,QAAQ,EAAEkC,GAAG,EAAEnC,QAAQ,KAAK;EAC7D,MAAM2D,KAAK,GAAG,MAAM1D,QAAQ,CAAC2D,cAAc,CAAC,CAAC;EAE7C,MAAMC,UAAU,GAAG,MAAM1B,GAAG,CAAC2B,WAAW,CAAC,MAAM,EAAE,CAAC,EAAEH,KAAK,CAAC;EAC1D,MAAMI,KAAK,GAAGF,UAAU,CAACG,GAAG,CAACC,KAAK,KAAK;IACrCd,IAAI,EAAEc,KAAK,CAACC,eAAe;IAC3BC,IAAI,EAAEF,KAAK,CAACE;EACd,CAAC,CAAC,CAAC;EAEHnE,QAAQ,CAACjB,WAAW,CAACgF,KAAK,CAAC,CAAC;AAC9B,CAAC;;AAKD;AACA,OAAO,MAAMK,sBAAsB,GAAG,MAAAA,CAAOC,IAAI,EAAEC,IAAI,EAAElC,MAAM,EAAEnC,QAAQ,KAAK;EAC5E,IAAI;IACF;IACA,MAAMsE,YAAY,GAAG,IAAIlG,MAAM,CAAC6C,QAAQ,CAACmD,IAAI,CAAClD,OAAO,EAAEvB,OAAO,EAAEK,QAAQ,CAAC;IACzE,MAAMuE,YAAY,GAAG,IAAInG,MAAM,CAAC6C,QAAQ,CAACoD,IAAI,CAACnD,OAAO,EAAEvB,OAAO,EAAEK,QAAQ,CAAC;;IAEzE;IACA,MAAMwE,YAAY,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CACrCJ,YAAY,CAACK,aAAa,CAAC,CAAC,EAC5BL,YAAY,CAACM,aAAa,CAAC,CAAC,CAC7B,CAAC;IAEF,MAAMC,YAAY,GAAG,MAAMJ,OAAO,CAACC,GAAG,CAAC,CACrCH,YAAY,CAACI,aAAa,CAAC,CAAC,EAC5BJ,YAAY,CAACK,aAAa,CAAC,CAAC,CAC7B,CAAC;;IAEF;IACA,MAAME,qBAAqB,GAAGN,YAAY,CAACT,GAAG,CAACgB,OAAO,IAAI3G,MAAM,CAACyC,KAAK,CAAC0B,WAAW,CAACwC,OAAO,CAACvC,QAAQ,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;IAChH,MAAMwC,qBAAqB,GAAGH,YAAY,CAACd,GAAG,CAACgB,OAAO,IAAI3G,MAAM,CAACyC,KAAK,CAAC0B,WAAW,CAACwC,OAAO,CAACvC,QAAQ,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;IAEhH,OAAO;MACL4B,IAAI,EAAE;QACJO,aAAa,EAAEG,qBAAqB,CAAC,CAAC,CAAC;QACvCF,aAAa,EAAEE,qBAAqB,CAAC,CAAC;MACxC,CAAC;MACDT,IAAI,EAAE;QACJM,aAAa,EAAEK,qBAAqB,CAAC,CAAC,CAAC;QACvCJ,aAAa,EAAEI,qBAAqB,CAAC,CAAC;MACxC;IACF,CAAC;EACH,CAAC,CAAC,OAAOtD,KAAK,EAAE;IACdD,OAAO,CAACC,KAAK,CAAC,oCAAoC,EAAEA,KAAK,CAAC;IAC1D,OAAO;MAAE0C,IAAI,EAAE;QAAEO,aAAa,EAAE,GAAG;QAAEC,aAAa,EAAE;MAAI,CAAC;MAAEP,IAAI,EAAE;QAAEM,aAAa,EAAE,GAAG;QAAEC,aAAa,EAAE;MAAI;IAAE,CAAC;EAC/G;AACF,CAAC;;AAID;AACA,OAAO,MAAMK,iBAAiB,GAAGA,CAACC,kBAAkB,EAAEnF,QAAQ,KAAK;EACjEA,QAAQ,CAACnB,SAAS,CAACsG,kBAAkB,CAAC,CAAC;AACzC,CAAC;AAKD,OAAO,MAAMC,WAAW,GAAG,MAAAA,CAAOnF,QAAQ,EAAEoF,WAAW,EAAEC,WAAW,EAAEtF,QAAQ,KAAK;EACjF,IAAI;IACF,MAAMuE,YAAY,GAAG,IAAIlG,MAAM,CAAC6C,QAAQ,CAACmE,WAAW,EAAEzF,OAAO,EAAEK,QAAQ,CAAC;IACxE,MAAMuE,YAAY,GAAG,IAAInG,MAAM,CAAC6C,QAAQ,CAACoE,WAAW,EAAE1F,OAAO,EAAEK,QAAQ,CAAC;;IAExE;IACA,MAAM,CAACsF,iBAAiB,EAAEC,iBAAiB,CAAC,GAAG,MAAMd,OAAO,CAACC,GAAG,CAAC,CAC/DJ,YAAY,CAACK,aAAa,CAAC,CAAC,EAC5BL,YAAY,CAACM,aAAa,CAAC,CAAC,CAC7B,CAAC;IACF,MAAMY,YAAY,GAAGD,iBAAiB,GAAGD,iBAAiB;IAC1D,MAAMG,YAAY,GAAGH,iBAAiB,GAAGC,iBAAiB;;IAE1D;IACA,MAAM,CAACG,iBAAiB,EAAEC,iBAAiB,CAAC,GAAG,MAAMlB,OAAO,CAACC,GAAG,CAAC,CAC/DH,YAAY,CAACI,aAAa,CAAC,CAAC,EAC5BJ,YAAY,CAACK,aAAa,CAAC,CAAC,CAC7B,CAAC;IACF,MAAMgB,YAAY,GAAGD,iBAAiB,GAAGD,iBAAiB;IAC1D,MAAMG,YAAY,GAAGH,iBAAiB,GAAGC,iBAAiB;;IAE1D;IACA5F,QAAQ,CAACN,aAAa,CAAC;MACrB6B,SAAS,EAAE,MAAM;MACjBwE,IAAI,EAAE;QACJnB,aAAa,EAAEvG,MAAM,CAACyC,KAAK,CAAC0B,WAAW,CAAC+C,iBAAiB,CAAC9C,QAAQ,CAAC,CAAC,EAAE,OAAO,CAAC;QAC9EoC,aAAa,EAAExG,MAAM,CAACyC,KAAK,CAAC0B,WAAW,CAACgD,iBAAiB,CAAC/C,QAAQ,CAAC,CAAC,EAAE,OAAO,CAAC;QAC9EuD,QAAQ,EAAEP,YAAY;QACtBQ,QAAQ,EAAEP;MACZ;IACF,CAAC,CAAC,CAAC;IACH1F,QAAQ,CAACN,aAAa,CAAC;MACrB6B,SAAS,EAAE,MAAM;MACjBwE,IAAI,EAAE;QACJnB,aAAa,EAAEvG,MAAM,CAACyC,KAAK,CAAC0B,WAAW,CAACmD,iBAAiB,CAAClD,QAAQ,CAAC,CAAC,EAAE,OAAO,CAAC;QAC9EoC,aAAa,EAAExG,MAAM,CAACyC,KAAK,CAAC0B,WAAW,CAACoD,iBAAiB,CAACnD,QAAQ,CAAC,CAAC,EAAE,OAAO,CAAC;QAC9EuD,QAAQ,EAAEH,YAAY;QACtBI,QAAQ,EAAEH;MACZ;IACF,CAAC,CAAC,CAAC;EACL,CAAC,CAAC,OAAOnE,KAAK,EAAE;IACdD,OAAO,CAACC,KAAK,CAAC,6CAA6C,EAAEA,KAAK,CAAC;EACrE;AACF,CAAC;AAED,OAAO,MAAMuE,cAAc,GAAG,MAAAA,CAAOjG,QAAQ,EAAEkG,eAAe,EAAEC,YAAY,EAAEC,aAAa,EAAEC,WAAW,EAAE/C,MAAM,EAAEvD,QAAQ,KAAK;EAC7H,IAAI;IACFA,QAAQ,CAACV,WAAW,CAAC,CAAC,CAAC;IAEvB,MAAMuD,MAAM,GAAG5C,QAAQ,CAAC6C,SAAS,CAAC,CAAC;IACnC,MAAMjB,WAAW,GAAGsE,eAAe,KAAK,MAAM,GAAGC,YAAY,CAAC/B,IAAI,GAAG+B,YAAY,CAAC9B,IAAI;;IAEtF;IACA,MAAM+B,aAAa,CAACtD,OAAO,CAACF,MAAM,CAAC,CAACG,OAAO,CAACnB,WAAW,CAACV,OAAO,EAAEoC,MAAM,CAAC;IAExE,IAAIN,WAAW;IACf,IAAIqD,WAAW,KAAK,MAAM,EAAE;MAC1BrD,WAAW,GAAG,MAAMpB,WAAW,CAACkB,OAAO,CAACF,MAAM,CAAC,CAACW,UAAU,CAACD,MAAM,CAAC;IACpE,CAAC,MAAM;MACLN,WAAW,GAAG,MAAMpB,WAAW,CAACkB,OAAO,CAACF,MAAM,CAAC,CAACY,UAAU,CAACF,MAAM,CAAC;IACpE;IAEA,MAAMN,WAAW,CAACC,IAAI,CAAC,CAAC;IAExBlD,QAAQ,CAACT,WAAW,CAAC0D,WAAW,CAACE,IAAI,CAAC,CAAC;EAEzC,CAAC,CAAC,OAAOxB,KAAK,EAAE;IACdD,OAAO,CAACC,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;IAC/C3B,QAAQ,CAACR,QAAQ,CAAC,CAAC,CAAC;EACtB;AACF,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}